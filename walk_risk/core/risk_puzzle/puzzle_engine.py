"""Risk Puzzle Engine - ë¦¬ìŠ¤í¬ë¥¼ í¼ì¦ë¡œ ë³€í™˜í•˜ëŠ” ì—”ì§„"""

from dataclasses import dataclass, field
from typing import List, Dict, Optional, Tuple
from enum import Enum
import random
from datetime import datetime


class PuzzleDifficulty(Enum):
    BEGINNER = "beginner"      # ëª…í™•í•œ ë‹¨ì„œ 3ê°œ
    INTERMEDIATE = "intermediate"  # ì• ë§¤í•œ ë‹¨ì„œ 5ê°œ
    ADVANCED = "advanced"      # ëª¨ìˆœëœ ë‹¨ì„œ 7ê°œ
    MASTER = "master"         # ìˆ¨ê²¨ì§„ ì§„ì‹¤ ì°¾ê¸°


class PuzzleType(Enum):
    PRICE_DROP = "price_drop"        # "ì™œ ë–¨ì–´ì¡Œì„ê¹Œ?"
    PRICE_SURGE = "price_surge"      # "ì™œ ì˜¬ëì„ê¹Œ?"
    VOLATILITY = "volatility"        # "ì™œ ë³€ë™ì„±ì´ í´ê¹Œ?"
    DIVERGENCE = "divergence"        # "ì™œ ì„¹í„°ì™€ ë‹¤ë¥´ê²Œ ì›€ì§ì¼ê¹Œ?"
    MYSTERY = "mystery"              # "ë­”ê°€ ì´ìƒí•œë°?"


@dataclass
class RiskPuzzle:
    """í”Œë ˆì´ì–´ê°€ í’€ì–´ì•¼ í•  ë¦¬ìŠ¤í¬ í¼ì¦"""
    
    puzzle_id: str
    title: str                      # "ì‚¼ì„±ì „ì -10% ë¯¸ìŠ¤í„°ë¦¬"
    description: str                 # ìƒí™© ì„¤ëª…
    puzzle_type: PuzzleType
    difficulty: PuzzleDifficulty
    
    # í¼ì¦ ë°ì´í„°
    target_symbol: str               # ëŒ€ìƒ ì£¼ì‹
    event_data: Dict                 # ì´ë²¤íŠ¸ ì •ë³´
    
    # ìˆ¨ê²¨ì§„ ì§„ì‹¤ (í”Œë ˆì´ì–´ê°€ ì°¾ì•„ì•¼ í•  ê²ƒ)
    hidden_truth: str                # "ë°˜ë„ì²´ ìˆ˜ìš” íšŒë³µ ì‹ í˜¸"
    correct_hypothesis: str          # "ì¼ì‹œì  ê³¼ë§¤ë„"
    
    # ë‹¨ì„œë“¤
    available_clues: List['Clue'] = field(default_factory=list)
    discovered_clues: List['Clue'] = field(default_factory=list)
    
    # ë³´ìƒ
    base_reward_xp: int = 100
    time_bonus_multiplier: float = 2.0  # ë¹¨ë¦¬ í’€ìˆ˜ë¡ ë³´ë„ˆìŠ¤
    
    # ìƒíƒœ
    is_solved: bool = False
    solve_time: Optional[float] = None
    player_hypothesis: Optional[str] = None
    
    def calculate_reward(self, time_taken: float, accuracy: float) -> Tuple[int, str]:
        """í¼ì¦ í•´ê²° ë³´ìƒ ê³„ì‚°"""
        # ê¸°ë³¸ ë³´ìƒ
        xp = self.base_reward_xp
        
        # ì •í™•ë„ ë³´ë„ˆìŠ¤ (0~100%)
        xp *= (1 + accuracy)
        
        # ì‹œê°„ ë³´ë„ˆìŠ¤ (ë¹ ë¥¼ìˆ˜ë¡ ë†’ìŒ)
        if time_taken < 60:  # 1ë¶„ ì´ë‚´
            xp *= self.time_bonus_multiplier
            
        # ë‚œì´ë„ ë³´ë„ˆìŠ¤
        difficulty_multipliers = {
            PuzzleDifficulty.BEGINNER: 1.0,
            PuzzleDifficulty.INTERMEDIATE: 1.5,
            PuzzleDifficulty.ADVANCED: 2.0,
            PuzzleDifficulty.MASTER: 3.0
        }
        xp *= difficulty_multipliers[self.difficulty]
        
        # íšë“ ìŠ¤í‚¬ ê²°ì •
        skill_gained = self._determine_skill_reward(accuracy)
        
        return int(xp), skill_gained
    
    def _determine_skill_reward(self, accuracy: float) -> str:
        """ì •í™•ë„ì— ë”°ë¥¸ ìŠ¤í‚¬ ë³´ìƒ"""
        if accuracy >= 0.9:
            return f"ë§ˆìŠ¤í„°: {self.puzzle_type.value} ë¶„ì„"
        elif accuracy >= 0.7:
            return f"ìˆ™ë ¨: {self.puzzle_type.value} í•´ì„"
        elif accuracy >= 0.5:
            return f"ì´ˆê¸‰: {self.puzzle_type.value} ì´í•´"
        else:
            return f"ê²½í—˜: {self.puzzle_type.value} ì‹¤íŒ¨ì—ì„œ ë°°ì›€"


class PuzzleEngine:
    """ë¦¬ìŠ¤í¬ í¼ì¦ ìƒì„± ë° ê´€ë¦¬ ì—”ì§„"""
    
    def __init__(self):
        self.active_puzzles: Dict[str, RiskPuzzle] = {}
        self.puzzle_templates = self._load_puzzle_templates()
        
    def _load_puzzle_templates(self) -> Dict:
        """í¼ì¦ í…œí”Œë¦¿ ë¡œë“œ"""
        return {
            PuzzleType.PRICE_DROP: [
                {
                    "title_format": "{symbol} {change}% ê¸‰ë½ì˜ ë¹„ë°€",
                    "hidden_truths": [
                        "ì‹¤ì  ë°œí‘œ ì „ ë¶ˆì•ˆê°",
                        "ì—…ì¢… ì „ì²´ ì¡°ì •",
                        "ëŒ€ì£¼ì£¼ ë§¤ë„ ë£¨ë¨¸",
                        "ê·œì œ ë¦¬ìŠ¤í¬ ë¶€ìƒ",
                        "ê¸°ìˆ ì  ê³¼ë§¤ë„"
                    ],
                    "correct_hypotheses": [
                        "ì¼ì‹œì  ê³¼ë§¤ë„ - ë§¤ìˆ˜ ê¸°íšŒ",
                        "êµ¬ì¡°ì  ë¬¸ì œ - ì¶”ê°€ í•˜ë½ ì˜ˆìƒ",
                        "ì„¹í„° ë¡œí…Œì´ì…˜ - ê´€ë§ í•„ìš”"
                    ]
                },
                {
                    "title_format": "{symbol} ì™œ ì´ë ‡ê²Œ ë–¨ì–´ì¡Œì„ê¹Œ?",
                    "hidden_truths": [
                        "ê²½ìŸì‚¬ ì‹ ì œí’ˆ ì¶œì‹œ",
                        "í•µì‹¬ ì¸ë ¥ ì´íƒˆ",
                        "í•´ì™¸ ì‹œì¥ ì² ìˆ˜ ê²°ì •",
                        "ì›ìì¬ ê°€ê²© ê¸‰ë“±",
                        "í™˜ìœ¨ ë¶ˆë¦¬ ì˜í–¥"
                    ],
                    "correct_hypotheses": [
                        "ê²½ìŸë ¥ ì•½í™” - ì¥ê¸° í•˜ë½ ì˜ˆìƒ",
                        "ë‹¨ê¸° ì•…ì¬ - ì €ì  ë§¤ìˆ˜ ê¸°íšŒ",
                        "ì—…ì¢… íŠ¹ì„± - ì‚¬ì´í´ ì €ì "
                    ]
                },
                {
                    "title_format": "{symbol} {change}% í­ë½, ì§„ì§œ ì´ìœ ëŠ”?",
                    "hidden_truths": [
                        "íšŒê³„ ê°ì‚¬ ì§€ì  ì‚¬í•­",
                        "ì†Œì†¡ ë¦¬ìŠ¤í¬ ë¶€ê°",
                        "ì •ë¶€ ê·œì œ ê°•í™” ë°œí‘œ",
                        "ê³µê¸‰ë§ ì°¨ì§ˆ ì‹¬í™”",
                        "ì£¼ìš” ê³ ê°ì‚¬ ì´íƒˆ"
                    ],
                    "correct_hypotheses": [
                        "ì‹¬ê°í•œ ë¦¬ìŠ¤í¬ - ì†ì ˆ í•„ìš”",
                        "ê³¼ë¯¼ ë°˜ì‘ - ë¶„í•  ë§¤ìˆ˜",
                        "ë¶ˆí™•ì‹¤ì„± ë†’ìŒ - ê´€ë§"
                    ]
                }
            ],
            PuzzleType.PRICE_SURGE: [
                {
                    "title_format": "{symbol} {change}% ê¸‰ë“±ì˜ ì´ìœ ",
                    "hidden_truths": [
                        "M&A ë£¨ë¨¸",
                        "ì‹ ì œí’ˆ ì¶œì‹œ ì„ë°•",
                        "ì‹¤ì  ì„œí”„ë¼ì´ì¦ˆ ì˜ˆìƒ",
                        "ê¸°ê´€ ë§¤ì§‘",
                        "ê³µë§¤ë„ ìˆì»¤ë²„ë§"
                    ],
                    "correct_hypotheses": [
                        "ì§€ì† ìƒìŠ¹ ê°€ëŠ¥ - ì¶”ê°€ ë§¤ìˆ˜",
                        "ê³¼ì—´ êµ­ë©´ - ì°¨ìµ ì‹¤í˜„",
                        "ë³€ë™ì„± ì¥ì„¸ - ë¶„í•  ë§¤ìˆ˜"
                    ]
                },
                {
                    "title_format": "{symbol} ê°‘ìê¸° ì™œ ì˜¬ëì„ê¹Œ?",
                    "hidden_truths": [
                        "ì •ë¶€ ì •ì±… ìˆ˜í˜œ ë°œí‘œ",
                        "ëŒ€ê·œëª¨ ìˆ˜ì£¼ ê³„ì•½ ì²´ê²°",
                        "ì™¸êµ­ì¸ ëŒ€ëŸ‰ ë§¤ìˆ˜",
                        "í…Œë§ˆì£¼ í¸ì…",
                        "ìì‚¬ì£¼ ë§¤ì… ê³µì‹œ"
                    ],
                    "correct_hypotheses": [
                        "ì‹¤ì§ˆì  í˜¸ì¬ - ì¥ê¸° ë³´ìœ ",
                        "ì¼ì‹œì  í…Œë§ˆ - ë‹¨ê¸° ë§¤ë§¤",
                        "ê³¼ì—´ ì‹ í˜¸ - ì¼ë¶€ ìµì ˆ"
                    ]
                },
                {
                    "title_format": "{symbol} {change}% í­ë“±, ì´ê²Œ ì§„ì§œì¼ê¹Œ?",
                    "hidden_truths": [
                        "ì‹ ì‚¬ì—… ì§„ì¶œ ê³µì‹œ",
                        "íšê¸°ì  ê¸°ìˆ  ê°œë°œ ì„±ê³µ",
                        "ë¸”ë¡ë”œ ë§¤ê° ì™„ë£Œ",
                        "í•´ì™¸ ëŒ€ê¸°ì—… íŒŒíŠ¸ë„ˆì‹­",
                        "ì‹¤ì  ì–´ë‹ ì„œí”„ë¼ì´ì¦ˆ"
                    ],
                    "correct_hypotheses": [
                        "í€ë”ë©˜í„¸ ê°œì„  - ì¥ê¸° ìƒìŠ¹ ê¸°ëŒ€",
                        "ê¸°ëŒ€ê° ì„ ë°˜ì˜ - ì¡°ì • í›„ ë§¤ìˆ˜",
                        "ì‘ì „ì„± ê¸‰ë“± - ì£¼ì˜ í•„ìš”"
                    ]
                }
            ],
            PuzzleType.VOLATILITY: [
                {
                    "title_format": "{symbol} ë¡¤ëŸ¬ì½”ìŠ¤í„° ì¥ì„¸ì˜ ë¹„ë°€",
                    "hidden_truths": [
                        "ì˜µì…˜ ë§Œê¸°ì¼ íš¨ê³¼",
                        "ê¸°ê´€ vs ê°œì¸ ë§¤ë§¤ ì¶©ëŒ",
                        "ë‰´ìŠ¤ í˜¼ì¬ë¡œ ì¸í•œ í˜¼ë€",
                        "ì•Œê³ ë¦¬ì¦˜ íŠ¸ë ˆì´ë”© ì˜í–¥",
                        "ì‹œì¥ ë¶ˆí™•ì‹¤ì„± ì¦ê°€"
                    ],
                    "correct_hypotheses": [
                        "ë³€ë™ì„± ì¥ì„¸ - ë°•ìŠ¤ê¶Œ ë§¤ë§¤",
                        "ë°©í–¥ íƒìƒ‰ ì¤‘ - ê´€ë§",
                        "ì„¸ë ¥ ë¬¼ëŸ‰ êµì²´ - ê±°ë˜ëŸ‰ ì£¼ì‹œ"
                    ]
                },
                {
                    "title_format": "{symbol} ê¸‰ë“±ë½ ë°˜ë³µ, ë¬´ìŠ¨ ì¼ì´?",
                    "hidden_truths": [
                        "ë‹¨ê¸° ì„¸ë ¥ ê°œì… ì˜ì‹¬",
                        "ì‹¤ì  ë°œí‘œ ì•ë‘” ë¶ˆí™•ì‹¤ì„±",
                        "ì‹œì¥ ì „ì²´ ë³€ë™ì„± í™•ëŒ€",
                        "ë ˆë²„ë¦¬ì§€ ETF ì²­ì‚° ì˜í–¥",
                        "ì •ì±… ë¶ˆí™•ì‹¤ì„±"
                    ],
                    "correct_hypotheses": [
                        "ë‹¨ê¸° ë§¤ë§¤ ê¸°íšŒ - ìŠ¤ìœ™ íŠ¸ë ˆì´ë”©",
                        "ë¦¬ìŠ¤í¬ íšŒí”¼ - í¬ì§€ì…˜ ì¶•ì†Œ",
                        "ë³€ë™ì„± ë§¤ë„ ì „ëµ"
                    ]
                },
                {
                    "title_format": "{symbol} ì™œ ì´ë ‡ê²Œ ì¶œë ì´ë‚˜ìš”?",
                    "hidden_truths": [
                        "ê±°ë˜ëŸ‰ ê¸‰ì¦ êµ¬ê°„",
                        "í…Œë§ˆ ë¡œí…Œì´ì…˜ ì§„í–‰ ì¤‘",
                        "ì™¸êµ­ì¸/ê¸°ê´€ ìˆ˜ê¸‰ ë¶ˆê· í˜•",
                        "ì§€ì •ê°€/ì‹œì¥ê°€ ì£¼ë¬¸ ì¶©ëŒ",
                        "ìœ ë™ì„± ë¶€ì¡±"
                    ],
                    "correct_hypotheses": [
                        "ë³€ë™ì„± í™œìš© - ë¶„í•  ë§¤ìˆ˜/ë§¤ë„",
                        "ì•ˆì • ì‹œê¹Œì§€ ëŒ€ê¸°",
                        "í—·ì§€ í¬ì§€ì…˜ êµ¬ì¶•"
                    ]
                }
            ],
            PuzzleType.DIVERGENCE: [
                {
                    "title_format": "{symbol}, ì„¹í„°ì™€ ì™œ ë‹¤ë¥´ê²Œ ì›€ì§ì¼ê¹Œ?",
                    "hidden_truths": [
                        "ê°œë³„ í˜¸ì¬/ì•…ì¬ ì¡´ì¬",
                        "ê²½ìŸì‚¬ ëŒ€ë¹„ ì°¨ë³„í™” ìš”ì¸",
                        "ìˆ˜ì¶œ ë¹„ì¤‘ ì°¨ì´",
                        "ì›ê°€ êµ¬ì¡° ì°¨ë³„ì„±",
                        "ì‚¬ì—… í¬íŠ¸í´ë¦¬ì˜¤ ë…ìì„±"
                    ],
                    "correct_hypotheses": [
                        "ì„¹í„° ëŒ€ë¹„ ìš°ìœ„ - ë¹„ì¤‘ í™•ëŒ€",
                        "ì¼ì‹œì  ê´´ë¦¬ - íšŒê·€ ê¸°ëŒ€",
                        "êµ¬ì¡°ì  ì°¨ì´ - ë³„ë„ ë¶„ì„ í•„ìš”"
                    ]
                },
                {
                    "title_format": "{symbol} í˜¼ìë§Œ ë‹¤ë¥¸ ê¸¸ì„ ê°„ë‹¤",
                    "hidden_truths": [
                        "ë…ìì  ì‚¬ì—… ëª¨ë¸",
                        "ì‹ ì‚¬ì—… ëª¨ë©˜í…€",
                        "ê¸°ì—… ê³ ìœ  ì´ìŠˆ ë°œìƒ",
                        "M&A ëŒ€ìƒ ë£¨ë¨¸",
                        "ì§€ë°°êµ¬ì¡° ë³€í™”"
                    ],
                    "correct_hypotheses": [
                        "ë…ìì  ê°€ì¹˜ - ì—…ì¢…ê³¼ ë¶„ë¦¬ ë¶„ì„",
                        "ì°©ì‹œ íš¨ê³¼ - ì—…ì¢… ì¶”ì¢… ì˜ˆìƒ",
                        "í„´ì–´ë¼ìš´ë“œ ì‹ í˜¸ - ë§¤ìˆ˜ ê³ ë ¤"
                    ]
                },
                {
                    "title_format": "{symbol} ì‹œì¥ íë¦„ ë¬´ì‹œ ì¤‘?",
                    "hidden_truths": [
                        "ì‹¤ì  ê°€ì´ë˜ìŠ¤ ìƒí–¥",
                        "ëŒ€ì£¼ì£¼ ì§€ë¶„ ë³€ë™",
                        "ì‚¬ì—…ë¶€ ë§¤ê°/ì¸ìˆ˜",
                        "ë°°ë‹¹ ì •ì±… ë³€í™”",
                        "í•´ì™¸ ë²•ì¸ ì‹¤ì  í˜¸ì¡°"
                    ],
                    "correct_hypotheses": [
                        "ì•ŒíŒŒ ì°½ì¶œ ê°€ëŠ¥ - ì ê·¹ ë§¤ìˆ˜",
                        "ì¼ì‹œì  í˜„ìƒ - ì„¹í„° ë³µê·€ ëŒ€ê¸°",
                        "ì •ë³´ ë¹„ëŒ€ì¹­ - ì¶”ê°€ ì¡°ì‚¬ í•„ìš”"
                    ]
                }
            ],
            PuzzleType.MYSTERY: [
                {
                    "title_format": "{symbol} ë¯¸ìŠ¤í„°ë¦¬í•œ ì›€ì§ì„",
                    "hidden_truths": [
                        "ë‚´ë¶€ì ê±°ë˜ ì˜ì‹¬",
                        "ë¯¸ê³µê°œ ì •ë³´ ìœ ì¶œ ì¶”ì •",
                        "ì„¸ë ¥ ë§¤ì§‘ ì§„í–‰ ì¤‘",
                        "ì¡°ìš©í•œ ì‹¤ì  ê°œì„ ",
                        "ìˆ¨ê²¨ì§„ ìì‚° ê°€ì¹˜ ë¶€ê°"
                    ],
                    "correct_hypotheses": [
                        "ì •ë³´ ë¹„ëŒ€ì¹­ - ì†ŒëŸ‰ ì§„ì…",
                        "ë¦¬ìŠ¤í¬ ë†’ìŒ - ê´€ë§",
                        "ì¡°ì‚¬ í›„ ê²°ì • - ì¶”ê°€ ì •ë³´ ìˆ˜ì§‘"
                    ]
                },
                {
                    "title_format": "{symbol} ë­”ê°€ ì´ìƒí•œë°?",
                    "hidden_truths": [
                        "ê¸°ê´€ í¬ì§€ì…˜ ëŒ€ê·œëª¨ ë³€ë™",
                        "ê³µë§¤ë„ ì”ê³  ê¸‰ë³€",
                        "ì˜µì…˜ ì‹œì¥ ì´ìƒ ì‹ í˜¸",
                        "ê´€ë ¨ ì¢…ëª© ë™ë°˜ ì´ìƒ ì›€ì§ì„",
                        "ê±°ë˜ëŸ‰ ì—†ëŠ” ê°€ê²© ë³€ë™"
                    ],
                    "correct_hypotheses": [
                        "í° ì´ë²¤íŠ¸ ì„ë°• - ì¤€ë¹„",
                        "ë…¸ì´ì¦ˆ - ë¬´ì‹œ",
                        "ìœ„í—˜ ì‹ í˜¸ - í¬ì§€ì…˜ ì •ë¦¬"
                    ]
                },
                {
                    "title_format": "{symbol} ì„¤ëª…ì´ ì•ˆ ë˜ëŠ” ì›€ì§ì„",
                    "hidden_truths": [
                        "ì¡°ìš©í•œ êµ¬ì¡°ì¡°ì • ì§„í–‰",
                        "ë¹„ê³µê°œ ê³„ì•½ ì²´ê²°",
                        "ê·œì œ ë‹¹êµ­ ì¡°ì‚¬ ì§„í–‰",
                        "ì¸ìˆ˜í•©ë³‘ í˜‘ìƒ ì¤‘",
                        "í•µì‹¬ ì‚¬ì—… ì „ëµ ë³€ê²½"
                    ],
                    "correct_hypotheses": [
                        "ì •ë³´ ìˆ˜ì§‘ ìš°ì„  - ë§¤ë§¤ ë³´ë¥˜",
                        "ë¦¬ìŠ¤í¬ ëŒ€ë¹„ ìˆ˜ìµ ë‚®ìŒ - íŒ¨ìŠ¤",
                        "ì†ŒëŸ‰ ë¶„ì‚° íˆ¬ì - ê¸°íšŒ ì—¿ë³´ê¸°"
                    ]
                }
            ]
        }
    
    def create_puzzle(self, 
                     symbol: str,
                     market_event: Dict,
                     difficulty: PuzzleDifficulty) -> RiskPuzzle:
        """ì‹œì¥ ì´ë²¤íŠ¸ë¡œë¶€í„° í¼ì¦ ìƒì„±"""
        
        # ì´ë²¤íŠ¸ íƒ€ì… ê²°ì •
        puzzle_type = self._determine_puzzle_type(market_event)
        
        # í…œí”Œë¦¿ ì„ íƒ
        templates = self.puzzle_templates.get(puzzle_type, [])
        if not templates:
            templates = self.puzzle_templates[PuzzleType.MYSTERY]
        template = random.choice(templates)
        
        # ì§„ì‹¤ê³¼ ê°€ì„¤ ì„ íƒ
        hidden_truth = random.choice(template["hidden_truths"])
        correct_hypothesis = random.choice(template["correct_hypotheses"])
        
        # í¼ì¦ ìƒì„±
        puzzle = RiskPuzzle(
            puzzle_id=f"puzzle_{symbol}_{datetime.now().timestamp()}",
            title=template["title_format"].format(
                symbol=symbol,
                change=market_event.get('change_percent', 0)
            ),
            description=self._generate_description(symbol, market_event),
            puzzle_type=puzzle_type,
            difficulty=difficulty,
            target_symbol=symbol,
            event_data=market_event,
            hidden_truth=hidden_truth,
            correct_hypothesis=correct_hypothesis,
            available_clues=self._generate_clues(
                symbol, hidden_truth, difficulty
            )
        )
        
        self.active_puzzles[puzzle.puzzle_id] = puzzle
        return puzzle
    
    def _determine_puzzle_type(self, market_event: Dict) -> PuzzleType:
        """ë§ˆì¼“ ì´ë²¤íŠ¸ë¡œë¶€í„° í¼ì¦ íƒ€ì… ê²°ì •"""
        change = market_event.get('change_percent', 0)
        volatility = market_event.get('volatility', 0)
        
        if change < -5:
            return PuzzleType.PRICE_DROP
        elif change > 5:
            return PuzzleType.PRICE_SURGE
        elif volatility > 30:
            return PuzzleType.VOLATILITY
        elif market_event.get('sector_divergence', False):
            return PuzzleType.DIVERGENCE
        else:
            return PuzzleType.MYSTERY
    
    def _generate_description(self, symbol: str, event: Dict) -> str:
        """í¼ì¦ ì„¤ëª… ìƒì„±"""
        return f"""
ğŸ“Š ìƒí™©: {symbol}ì´(ê°€) {event.get('change_percent', 0):+.1f}% ë³€ë™í–ˆìŠµë‹ˆë‹¤.
ğŸ“ˆ ê±°ë˜ëŸ‰: í‰ì†Œ ëŒ€ë¹„ {event.get('volume_ratio', 1.0):.1f}ë°°
ğŸŒ ì‹œì¥: {event.get('market_sentiment', 'ì¤‘ë¦½')}
â° ì‹œê°„: {event.get('time', 'ì¥ì¤‘')}

ë¬´ì—‡ì´ ì´ ì›€ì§ì„ì„ ë§Œë“¤ì—ˆì„ê¹Œìš”?
ë‹¨ì„œë¥¼ ìˆ˜ì§‘í•˜ê³  ê°€ì„¤ì„ ì„¸ì›Œë³´ì„¸ìš”.
        """.strip()
    
    def _generate_clues(self, 
                       symbol: str,
                       hidden_truth: str,
                       difficulty: PuzzleDifficulty) -> List:
        """ë‚œì´ë„ì— ë”°ë¥¸ ë‹¨ì„œ ìƒì„±"""
        from .investigation import Clue, ClueType
        
        clue_counts = {
            PuzzleDifficulty.BEGINNER: 3,
            PuzzleDifficulty.INTERMEDIATE: 5,
            PuzzleDifficulty.ADVANCED: 7,
            PuzzleDifficulty.MASTER: 10
        }
        
        num_clues = clue_counts[difficulty]
        clues = []
        
        # ì§„ì‹¤ ë‹¨ì„œ (1~2ê°œ)
        clues.append(Clue(
            clue_type=ClueType.NEWS,
            content=self._create_truth_clue(hidden_truth),
            reliability=0.9 if difficulty == PuzzleDifficulty.BEGINNER else 0.7,
            cost_time=10,
            cost_energy=1
        ))
        
        # ë…¸ì´ì¦ˆ ë‹¨ì„œë“¤
        for _ in range(num_clues - 1):
            clues.append(self._create_noise_clue(difficulty))
        
        random.shuffle(clues)
        return clues
    
    def _create_truth_clue(self, hidden_truth: str) -> str:
        """ì§„ì‹¤ì„ ì•”ì‹œí•˜ëŠ” ë‹¨ì„œ ìƒì„±"""
        hints = {
            # PRICE_DROP ê´€ë ¨
            "ì‹¤ì  ë°œí‘œ ì „ ë¶ˆì•ˆê°": "ë‹¤ìŒ ì£¼ ì‹¤ì  ë°œí‘œ ì˜ˆì •, ì‹œì¥ ì˜ˆìƒì¹˜ í•˜íšŒ ìš°ë ¤",
            "ì—…ì¢… ì „ì²´ ì¡°ì •": "ë™ì¢… ì—…ê³„ ì£¼ì‹ë“¤ë„ ë™ë°˜ í•˜ë½ ì¤‘",
            "ëŒ€ì£¼ì£¼ ë§¤ë„ ë£¨ë¨¸": "ìµœëŒ€ì£¼ì£¼ ì§€ë¶„ ë³€ë™ ê³µì‹œëŠ” ì—†ìœ¼ë‚˜ ì‹œì¥ì— ë£¨ë¨¸ í™•ì‚°",
            "ê¸°ìˆ ì  ê³¼ë§¤ë„": "RSI 30 ì´í•˜, ë³¼ë¦°ì € ë°´ë“œ í•˜ë‹¨ ì´íƒˆ",
            "ê·œì œ ë¦¬ìŠ¤í¬ ë¶€ìƒ": "ì •ë¶€ ê·œì œ ê°•í™” ê´€ë ¨ ê¸°ì‚¬ ë‹¤ìˆ˜ ë…¸ì¶œ",
            "ê²½ìŸì‚¬ ì‹ ì œí’ˆ ì¶œì‹œ": "ì£¼ìš” ê²½ìŸì‚¬ê°€ ì°¨ì„¸ëŒ€ ì œí’ˆ ë°œí‘œ, ì‹œì¥ ë°˜ì‘ ê¸ì •ì ",
            "í•µì‹¬ ì¸ë ¥ ì´íƒˆ": "í•µì‹¬ ì—°êµ¬ì§„ ë˜ëŠ” ì„ì› í‡´ì‚¬ ì†Œì‹ì´ ì—…ê³„ì— í¼ì§",
            "í•´ì™¸ ì‹œì¥ ì² ìˆ˜ ê²°ì •": "íŠ¹ì • í•´ì™¸ ì‹œì¥ì—ì„œ ì‚¬ì—… ì² ìˆ˜ ê²€í†  ë³´ë„",
            "ì›ìì¬ ê°€ê²© ê¸‰ë“±": "ì£¼ìš” ì›ìì¬ ê°€ê²©ì´ ê¸‰ë“±í•˜ë©° ì›ê°€ ë¶€ë‹´ ìš°ë ¤",
            "í™˜ìœ¨ ë¶ˆë¦¬ ì˜í–¥": "ì›ë‹¬ëŸ¬ í™˜ìœ¨ ë³€ë™ìœ¼ë¡œ ìˆ˜ì¶œ ê¸°ì—… ì±„ì‚°ì„± ì•…í™” ì „ë§",
            "íšŒê³„ ê°ì‚¬ ì§€ì  ì‚¬í•­": "ê°ì‚¬ë³´ê³ ì„œì— íŠ¹ì´ì‚¬í•­ ê¸°ì¬ í™•ì¸",
            "ì†Œì†¡ ë¦¬ìŠ¤í¬ ë¶€ê°": "ëŒ€ê·œëª¨ ì§‘ë‹¨ ì†Œì†¡ ë˜ëŠ” íŠ¹í—ˆ ë¶„ìŸ ë‰´ìŠ¤",
            "ì •ë¶€ ê·œì œ ê°•í™” ë°œí‘œ": "ê´€ë ¨ ì‚°ì—… ê·œì œ ê°•í™” ì •ì±… ë°œí‘œ",
            "ê³µê¸‰ë§ ì°¨ì§ˆ ì‹¬í™”": "ë¶€í’ˆ ê³µê¸‰ ì§€ì—°ìœ¼ë¡œ ìƒì‚° ì°¨ì§ˆ ì˜ˆìƒ",
            "ì£¼ìš” ê³ ê°ì‚¬ ì´íƒˆ": "ëŒ€í˜• ê³ ê°ì‚¬ì™€ì˜ ê³„ì•½ ì¢…ë£Œ ë˜ëŠ” ì¶•ì†Œ ë³´ë„",

            # PRICE_SURGE ê´€ë ¨
            "M&A ë£¨ë¨¸": "ì¸ìˆ˜í•©ë³‘ ëŒ€ìƒì´ë¼ëŠ” ë£¨ë¨¸ê°€ ì‹œì¥ì— í™•ì‚°",
            "ì‹ ì œí’ˆ ì¶œì‹œ ì„ë°•": "í˜ì‹ ì  ì‹ ì œí’ˆ ì¶œì‹œ ì¼ì • ê³µê°œ",
            "ì‹¤ì  ì„œí”„ë¼ì´ì¦ˆ ì˜ˆìƒ": "ì¦ê¶Œì‚¬ë“¤ì˜ ì‹¤ì  ì „ë§ì¹˜ ìƒí–¥ ì¡°ì • ì‡ë”°ë¼",
            "ê¸°ê´€ ë§¤ì§‘": "ìµœê·¼ ê¸°ê´€ íˆ¬ìì ë§¤ìˆ˜ì„¸ ê¸‰ì¦ í¬ì°©",
            "ê³µë§¤ë„ ìˆì»¤ë²„ë§": "ê³µë§¤ë„ ì”ê³  ê¸‰ê°, ìˆì»¤ë²„ë§ ì§„í–‰ ì¤‘",
            "ì •ë¶€ ì •ì±… ìˆ˜í˜œ ë°œí‘œ": "ìƒˆë¡œìš´ ì •ë¶€ ì •ì±…ìœ¼ë¡œ í•´ë‹¹ ì—…ì¢… ìˆ˜í˜œ ì˜ˆìƒ",
            "ëŒ€ê·œëª¨ ìˆ˜ì£¼ ê³„ì•½ ì²´ê²°": "ëŒ€í˜• í”„ë¡œì íŠ¸ ìˆ˜ì£¼ ì„±ê³µ ê³µì‹œ",
            "ì™¸êµ­ì¸ ëŒ€ëŸ‰ ë§¤ìˆ˜": "ì™¸êµ­ì¸ íˆ¬ìì ì—°ì† ìˆœë§¤ìˆ˜ ê¸°ë¡",
            "í…Œë§ˆì£¼ í¸ì…": "ì¸ê¸° íˆ¬ì í…Œë§ˆì— í¸ì…ë˜ë©° ê´€ì‹¬ ê¸‰ì¦",
            "ìì‚¬ì£¼ ë§¤ì… ê³µì‹œ": "ëŒ€ê·œëª¨ ìì‚¬ì£¼ ë§¤ì… ê³„íš ë°œí‘œ",
            "ì‹ ì‚¬ì—… ì§„ì¶œ ê³µì‹œ": "ì„±ì¥ì„± ë†’ì€ ì‹ ì‚¬ì—… ì§„ì¶œ ë°œí‘œ",
            "íšê¸°ì  ê¸°ìˆ  ê°œë°œ ì„±ê³µ": "í•µì‹¬ ê¸°ìˆ  ê°œë°œ ë˜ëŠ” íŠ¹í—ˆ íšë“ ì†Œì‹",
            "ë¸”ë¡ë”œ ë§¤ê° ì™„ë£Œ": "ëŒ€ì£¼ì£¼ ë¬¼ëŸ‰ ë¸”ë¡ë”œ ì™„ë£Œë¡œ ì˜¤ë²„í–‰ í•´ì†Œ",
            "í•´ì™¸ ëŒ€ê¸°ì—… íŒŒíŠ¸ë„ˆì‹­": "ê¸€ë¡œë²Œ ê¸°ì—…ê³¼ì˜ ì „ëµì  ì œíœ´ ë°œí‘œ",
            "ì‹¤ì  ì–´ë‹ ì„œí”„ë¼ì´ì¦ˆ": "ì˜ˆìƒì„ í¬ê²Œ ìƒíšŒí•˜ëŠ” ì‹¤ì  ë°œí‘œ",

            # VOLATILITY ê´€ë ¨
            "ì˜µì…˜ ë§Œê¸°ì¼ íš¨ê³¼": "ì£¼ê°€ì§€ìˆ˜ ì˜µì…˜ ë§Œê¸°ì¼ ì „í›„ ë³€ë™ì„± í™•ëŒ€ íŒ¨í„´",
            "ê¸°ê´€ vs ê°œì¸ ë§¤ë§¤ ì¶©ëŒ": "ê¸°ê´€ ë§¤ë„ vs ê°œì¸ ë§¤ìˆ˜ ìˆ˜ê¸‰ ëŒ€ë¦½ ì¤‘",
            "ë‰´ìŠ¤ í˜¼ì¬ë¡œ ì¸í•œ í˜¼ë€": "í˜¸ì¬ì™€ ì•…ì¬ê°€ ë™ì‹œì— ë°œìƒí•˜ë©° ì‹œì¥ í˜¼ë€",
            "ì•Œê³ ë¦¬ì¦˜ íŠ¸ë ˆì´ë”© ì˜í–¥": "ëŒ€ëŸ‰ ì•Œê³ ë¦¬ì¦˜ ë§¤ë§¤ë¡œ ê¸‰ê²©í•œ ê°€ê²© ë³€ë™",
            "ì‹œì¥ ë¶ˆí™•ì‹¤ì„± ì¦ê°€": "ëŒ€ì™¸ ë³€ìˆ˜ ì¦ê°€ë¡œ ì „ë°˜ì  ì‹œì¥ ë¶ˆì•ˆ",
            "ë‹¨ê¸° ì„¸ë ¥ ê°œì… ì˜ì‹¬": "ê±°ë˜ëŸ‰ íŒ¨í„´ì´ ë¹„ì •ìƒì , ì„¸ë ¥ ê°œì… ì˜ì‹¬",
            "ì‹¤ì  ë°œí‘œ ì•ë‘” ë¶ˆí™•ì‹¤ì„±": "ì‹¤ì  ë°œí‘œ ì „ ëˆˆì¹˜ë³´ê¸° ì¥ì„¸",
            "ì‹œì¥ ì „ì²´ ë³€ë™ì„± í™•ëŒ€": "VIX ì§€ìˆ˜ ìƒìŠ¹, ì „ì²´ ì‹œì¥ ë³€ë™ì„± í™•ëŒ€",
            "ë ˆë²„ë¦¬ì§€ ETF ì²­ì‚° ì˜í–¥": "ë ˆë²„ë¦¬ì§€/ì¸ë²„ìŠ¤ ETF ë¦¬ë°¸ëŸ°ì‹± ë¬¼ëŸ‰ ì˜í–¥",
            "ì •ì±… ë¶ˆí™•ì‹¤ì„±": "ê¸ˆë¦¬, í†µí™”ì •ì±… ë“± ì •ì±… ë°©í–¥ ë¶ˆí™•ì‹¤",
            "ê±°ë˜ëŸ‰ ê¸‰ì¦ êµ¬ê°„": "í‰ì†Œ ëŒ€ë¹„ ê±°ë˜ëŸ‰ 3ë°° ì´ìƒ í­ì¦",
            "í…Œë§ˆ ë¡œí…Œì´ì…˜ ì§„í–‰ ì¤‘": "ì‹œì¥ ì£¼ë„ í…Œë§ˆ êµì²´ ì¤‘ ë³€ë™ì„± í™•ëŒ€",
            "ì™¸êµ­ì¸/ê¸°ê´€ ìˆ˜ê¸‰ ë¶ˆê· í˜•": "ì™¸êµ­ì¸ê³¼ ê¸°ê´€ì˜ ë§¤ë§¤ ë°©í–¥ ì—‡ê°ˆë¦¼",
            "ì§€ì •ê°€/ì‹œì¥ê°€ ì£¼ë¬¸ ì¶©ëŒ": "ëŒ€ëŸ‰ ì£¼ë¬¸ ì²´ê²°ë¡œ ì¸í•œ ìˆœê°„ ê¸‰ë³€ë™",
            "ìœ ë™ì„± ë¶€ì¡±": "ê±°ë˜ëŸ‰ ë¶€ì¡±ìœ¼ë¡œ ì‘ì€ ì£¼ë¬¸ì—ë„ í° ë³€ë™",

            # DIVERGENCE ê´€ë ¨
            "ê°œë³„ í˜¸ì¬/ì•…ì¬ ì¡´ì¬": "ì—…ì¢…ê³¼ ë¬´ê´€í•œ ê¸°ì—… ê³ ìœ  ì´ìŠˆ ë°œìƒ",
            "ê²½ìŸì‚¬ ëŒ€ë¹„ ì°¨ë³„í™” ìš”ì¸": "ê²½ìŸì‚¬ì™€ ë‹¤ë¥¸ ë…ìì  ê°•ì  ë¶€ê°",
            "ìˆ˜ì¶œ ë¹„ì¤‘ ì°¨ì´": "ìˆ˜ì¶œ ë¹„ì¤‘ì— ë”°ë¥¸ í™˜ìœ¨ ì˜í–¥ ì°¨ì´",
            "ì›ê°€ êµ¬ì¡° ì°¨ë³„ì„±": "ì›ìì¬ ì˜ì¡´ë„ ì°¨ì´ë¡œ ìˆ˜ìµì„± ì°¨ë³„í™”",
            "ì‚¬ì—… í¬íŠ¸í´ë¦¬ì˜¤ ë…ìì„±": "íƒ€ì‚¬ì™€ ë‹¤ë¥¸ ì‚¬ì—… êµ¬ì„±ìœ¼ë¡œ ë…ì í–‰ë³´",
            "ë…ìì  ì‚¬ì—… ëª¨ë¸": "ì—…ì¢… ë‚´ ìœ ì¼í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ëª¨ë¸ ë³´ìœ ",
            "ì‹ ì‚¬ì—… ëª¨ë©˜í…€": "ì‹ ì‚¬ì—… ì„±ê³¼ë¡œ ì—…ì¢… í‰ê·  ëŒ€ë¹„ ì„±ì¥",
            "ê¸°ì—… ê³ ìœ  ì´ìŠˆ ë°œìƒ": "ê°œë³„ ê¸°ì—…ë§Œì˜ íŠ¹ìˆ˜ ìƒí™© ë°œìƒ",
            "M&A ëŒ€ìƒ ë£¨ë¨¸": "ì¸ìˆ˜í•©ë³‘ ëŒ€ìƒìœ¼ë¡œ í”„ë¦¬ë¯¸ì—„ ê¸°ëŒ€",
            "ì§€ë°°êµ¬ì¡° ë³€í™”": "ëŒ€ì£¼ì£¼ ë³€ê²½, ê²½ì˜ê¶Œ ë¶„ìŸ ë“± ì´ìŠˆ",
            "ì‹¤ì  ê°€ì´ë˜ìŠ¤ ìƒí–¥": "íšŒì‚¬ê°€ ì‹¤ì  ì „ë§ì„ ìƒí–¥ ì¡°ì •",
            "ëŒ€ì£¼ì£¼ ì§€ë¶„ ë³€ë™": "ëŒ€ì£¼ì£¼ ì§€ë¶„ ë§¤ì…/ë§¤ê° ê³µì‹œ",
            "ì‚¬ì—…ë¶€ ë§¤ê°/ì¸ìˆ˜": "ë¹„í•µì‹¬ ì‚¬ì—…ë¶€ ë§¤ê° ë˜ëŠ” ì‹ ê·œ ì‚¬ì—… ì¸ìˆ˜",
            "ë°°ë‹¹ ì •ì±… ë³€í™”": "ë°°ë‹¹ í™•ëŒ€ ë˜ëŠ” ì£¼ì£¼í™˜ì› ì •ì±… ë°œí‘œ",
            "í•´ì™¸ ë²•ì¸ ì‹¤ì  í˜¸ì¡°": "í•´ì™¸ ìíšŒì‚¬ ì‹¤ì  ê°œì„  ì†Œì‹",

            # MYSTERY ê´€ë ¨
            "ë‚´ë¶€ì ê±°ë˜ ì˜ì‹¬": "ì´ìƒ ë§¤ë§¤ íŒ¨í„´, ë‚´ë¶€ì ì •ë³´ í™œìš© ì˜ì‹¬",
            "ë¯¸ê³µê°œ ì •ë³´ ìœ ì¶œ ì¶”ì •": "ê³µì‹œ ì „ ì£¼ê°€ ì„ ë°˜ì˜, ì •ë³´ ìœ ì¶œ ì˜ì‹¬",
            "ì„¸ë ¥ ë§¤ì§‘ ì§„í–‰ ì¤‘": "íŠ¹ì • ì„¸ë ¥ì˜ ë¬¼ëŸ‰ í™•ë³´ íŒ¨í„´ í¬ì°©",
            "ì¡°ìš©í•œ ì‹¤ì  ê°œì„ ": "ëšœë ·í•œ ë‰´ìŠ¤ ì—†ì´ ì‹¤ì  ê°œì„  ì§„í–‰ ì¤‘",
            "ìˆ¨ê²¨ì§„ ìì‚° ê°€ì¹˜ ë¶€ê°": "ë¶€ë™ì‚°, ì§€ë¶„ ë“± ìˆ¨ì€ ìì‚° ê°€ì¹˜ ì£¼ëª©",
            "ê¸°ê´€ í¬ì§€ì…˜ ëŒ€ê·œëª¨ ë³€ë™": "ê¸°ê´€ íˆ¬ìì í¬ì§€ì…˜ ê¸‰ê²©íˆ ë³€ê²½",
            "ê³µë§¤ë„ ì”ê³  ê¸‰ë³€": "ê³µë§¤ë„ ì”ê³ ê°€ ê¸‰ê²©íˆ ì¦ê°€ ë˜ëŠ” ê°ì†Œ",
            "ì˜µì…˜ ì‹œì¥ ì´ìƒ ì‹ í˜¸": "ì˜µì…˜ ê±°ë˜ëŸ‰/ë¯¸ê²°ì œ ì•½ì • ì´ìƒ íŒ¨í„´",
            "ê´€ë ¨ ì¢…ëª© ë™ë°˜ ì´ìƒ ì›€ì§ì„": "ìíšŒì‚¬, ê´€ê³„ì‚¬ ë“± ê´€ë ¨ ì¢…ëª© ë™ë°˜ ë³€ë™",
            "ê±°ë˜ëŸ‰ ì—†ëŠ” ê°€ê²© ë³€ë™": "ê±°ë˜ëŸ‰ ì—†ì´ í˜¸ê°€ë§Œìœ¼ë¡œ ê°€ê²© ë³€ë™",
            "ì¡°ìš©í•œ êµ¬ì¡°ì¡°ì • ì§„í–‰": "ì¸ë ¥ ê°ì¶•, ì‚¬ì—…ë¶€ ì •ë¦¬ ë“± ì¡°ìš©íˆ ì§„í–‰ ì¤‘",
            "ë¹„ê³µê°œ ê³„ì•½ ì²´ê²°": "ì•„ì§ ê³µì‹œë˜ì§€ ì•Šì€ ëŒ€í˜• ê³„ì•½ ì¶”ì •",
            "ê·œì œ ë‹¹êµ­ ì¡°ì‚¬ ì§„í–‰": "ê¸ˆìœµë‹¹êµ­ ë˜ëŠ” ê³µì •ìœ„ ì¡°ì‚¬ ì§„í–‰ ì†Œë¬¸",
            "ì¸ìˆ˜í•©ë³‘ í˜‘ìƒ ì¤‘": "M&A í˜‘ìƒì´ ì§„í–‰ ì¤‘ì´ë¼ëŠ” ì¶”ì¸¡",
            "í•µì‹¬ ì‚¬ì—… ì „ëµ ë³€ê²½": "ì£¼ë ¥ ì‚¬ì—… ë°©í–¥ ì „í™˜ ê²€í†  ì¤‘"
        }
        return hints.get(hidden_truth, f"ê´€ë ¨ ì •ë³´: {hidden_truth}")
    
    def _create_noise_clue(self, difficulty: PuzzleDifficulty) -> 'Clue':
        """ë…¸ì´ì¦ˆ ë‹¨ì„œ ìƒì„±"""
        from .investigation import Clue, ClueType

        noise_contents = [
            # ê¸°ë³¸ ë…¸ì´ì¦ˆ
            "ì• ë„ë¦¬ìŠ¤íŠ¸ ëª©í‘œê°€ í•˜í–¥ ì¡°ì •",
            "ì™¸êµ­ì¸ ìˆœë§¤ë„ ì§€ì†",
            "ê¸°ê´€ ìˆœë§¤ìˆ˜ ì „í™˜",
            "ê³µë§¤ë„ ì”ê³  ì¦ê°€",
            "í”„ë¡œê·¸ë¨ ë§¤ë„ í˜¸ê°€ ëŒ€ê¸°",
            # ìˆ˜ê¸‰ ê´€ë ¨ ë…¸ì´ì¦ˆ
            "ê°œì¸ íˆ¬ìì ë§¤ìˆ˜ì„¸ ìœ ì…",
            "ì—°ê¸°ê¸ˆ ë¦¬ë°¸ëŸ°ì‹± ì˜ˆì •",
            "ETF ë¦¬ë°¸ëŸ°ì‹± ìˆ˜ìš” ì˜ˆìƒ",
            "ëŒ€ì°¨ê±°ë˜ ì”ê³  ë³€ë™",
            "ì‹ ìš©ì”ê³  ë¹„ìœ¨ ë³€í™”",
            # ê¸°ìˆ ì  ë¶„ì„ ë…¸ì´ì¦ˆ
            "MACD ê³¨ë“ í¬ë¡œìŠ¤ ì„ë°•",
            "20ì¼ ì´ë™í‰ê· ì„  ì§€ì§€",
            "60ì¼ì„  ëŒíŒŒ ì‹œë„",
            "ê±°ë˜ëŸ‰ ê°ì†Œ ì¶”ì„¸",
            "ë³¼ë¦°ì € ë°´ë“œ ì¤‘ì‹¬ì„  ê·¼ì ‘",
            # ì‹œì¥ í™˜ê²½ ë…¸ì´ì¦ˆ
            "ì—…ì¢… ì§€ìˆ˜ ë³´í•©ì„¸",
            "ì½”ìŠ¤í”¼ ëŒ€ë¹„ ì•½ì„¸",
            "ë™ì¢… ì—…ê³„ í‰ê·  ìˆ˜ìµë¥ ",
            "ì„¹í„° ìê¸ˆ ìœ ì¶œì… ì¤‘ë¦½",
            "ë² íƒ€ê°’ ì‹œì¥ í‰ê· ",
            # ê¸°ì—… ê´€ë ¨ ë…¸ì´ì¦ˆ
            "ì„ì› ìŠ¤í†¡ì˜µì…˜ í–‰ì‚¬",
            "ì†Œì•¡ì£¼ì£¼ í™œë™ ê°ì§€",
            "ë°°ë‹¹ë½ì¼ ì„ë°•",
            "ìœ ìƒì¦ì ê°€ëŠ¥ì„± ë‚®ìŒ",
            "CB/BW í–‰ì‚¬ê°€ ë„ë˜",
            # ë§¤í¬ë¡œ ë…¸ì´ì¦ˆ
            "ê¸ˆë¦¬ ë™ê²° ì˜ˆìƒ",
            "í™˜ìœ¨ ì•ˆì •ì„¸",
            "ì›ìì¬ ê°€ê²© ë³´í•©",
            "ê²½ê¸°ì„ í–‰ì§€ìˆ˜ ë³€ë™ ì—†ìŒ",
            "ì†Œë¹„ì ì‹¬ë¦¬ì§€ìˆ˜ ì¤‘ë¦½"
        ]

        # ë‚œì´ë„ì— ë”°ë¼ ë…¸ì´ì¦ˆì˜ ì‹ ë¢°ë„ ì¡°ì ˆ
        reliability_ranges = {
            PuzzleDifficulty.BEGINNER: (0.2, 0.4),
            PuzzleDifficulty.INTERMEDIATE: (0.3, 0.5),
            PuzzleDifficulty.ADVANCED: (0.4, 0.6),
            PuzzleDifficulty.MASTER: (0.5, 0.7)  # ë§ˆìŠ¤í„° ë ˆë²¨ì—ì„œëŠ” ë…¸ì´ì¦ˆë„ ê·¸ëŸ´ë“¯í•´ë³´ì„
        }

        min_rel, max_rel = reliability_ranges[difficulty]

        return Clue(
            clue_type=random.choice(list(ClueType)),
            content=random.choice(noise_contents),
            reliability=random.uniform(min_rel, max_rel),
            cost_time=random.randint(5, 15),
            cost_energy=random.randint(1, 3)
        )
    
    def submit_hypothesis(self, 
                         puzzle_id: str,
                         hypothesis: str,
                         evidence: List[str]) -> Tuple[float, str]:
        """í”Œë ˆì´ì–´ì˜ ê°€ì„¤ ì œì¶œ ë° í‰ê°€"""
        puzzle = self.active_puzzles.get(puzzle_id)
        if not puzzle:
            return 0.0, "í¼ì¦ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤"
        
        # ì •í™•ë„ ê³„ì‚°
        accuracy = self._calculate_accuracy(
            hypothesis,
            puzzle.correct_hypothesis,
            evidence,
            puzzle.discovered_clues
        )
        
        # í”¼ë“œë°± ìƒì„±
        feedback = self._generate_feedback(
            accuracy,
            puzzle.hidden_truth,
            hypothesis
        )
        
        # í¼ì¦ ì™„ë£Œ ì²˜ë¦¬
        puzzle.is_solved = True
        puzzle.player_hypothesis = hypothesis
        
        return accuracy, feedback
    
    def _calculate_accuracy(self,
                           player_hypothesis: str,
                           correct_hypothesis: str,
                           evidence: List[str],
                           discovered_clues: List) -> float:
        """ê°€ì„¤ì˜ ì •í™•ë„ ê³„ì‚°"""
        score = 0.0
        
        # ê°€ì„¤ ìœ ì‚¬ë„ (ê°„ë‹¨í•œ í‚¤ì›Œë“œ ë§¤ì¹­)
        hypothesis_keywords = set(player_hypothesis.lower().split())
        correct_keywords = set(correct_hypothesis.lower().split())
        
        if hypothesis_keywords & correct_keywords:
            score += 0.5
        
        # ì¦ê±° í’ˆì§ˆ
        if len(evidence) > 0:
            score += min(0.3, len(evidence) * 0.1)
        
        # ë°œê²¬í•œ ë‹¨ì„œì˜ í’ˆì§ˆ
        truth_clues = [c for c in discovered_clues if c.reliability > 0.7]
        if truth_clues:
            score += 0.2
        
        return min(1.0, score)
    
    def _generate_feedback(self, 
                          accuracy: float,
                          hidden_truth: str,
                          hypothesis: str) -> str:
        """í”Œë ˆì´ì–´ì—ê²Œ ì¤„ í”¼ë“œë°± ìƒì„±"""
        if accuracy >= 0.8:
            return f"""
ğŸ¯ í›Œë¥­í•©ë‹ˆë‹¤! ì •í™•í•œ ë¶„ì„ì´ì—ˆìŠµë‹ˆë‹¤.
ì§„ì‹¤: {hidden_truth}
ë‹¹ì‹ ì˜ í†µì°°ë ¥ì´ ì‹œì¥ì„ ì´ê²¼ìŠµë‹ˆë‹¤.
            """.strip()
        elif accuracy >= 0.5:
            return f"""
ğŸ‘ ê´œì°®ì€ ë¶„ì„ì´ì—ˆìŠµë‹ˆë‹¤.
ì§„ì‹¤: {hidden_truth}
ë°©í–¥ì€ ë§ì•˜ì§€ë§Œ ë” ê¹Šì€ ì¡°ì‚¬ê°€ í•„ìš”í–ˆìŠµë‹ˆë‹¤.
            """.strip()
        else:
            return f"""
ğŸ’¡ ì´ë²ˆì—” ë¹—ë‚˜ê°”ì§€ë§Œ ì¢‹ì€ ê²½í—˜ì´ì—ˆìŠµë‹ˆë‹¤.
ì§„ì‹¤: {hidden_truth}
ì‹¤íŒ¨ë„ ì†Œì¤‘í•œ í•™ìŠµì…ë‹ˆë‹¤. ë‹¤ìŒì—” ë” ë§ì€ ë‹¨ì„œë¥¼ ìˆ˜ì§‘í•´ë³´ì„¸ìš”.
            """.strip()